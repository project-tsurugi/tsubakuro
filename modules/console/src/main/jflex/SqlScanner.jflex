package com.tsurugidb.tsubakuro.console.parser;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

@SuppressFBWarnings(
    justification = "generated by JFlex"
)
%%

%class SqlScannerFlex
%unicode
%ignorecase

%type int
%eofval{
    return eof();
%eofval}

%char
%line
%column

%{
    static final int SAW_EOF = -1;

    static final int SAW_DELIMITER = 0;

    static final int SAW_BODY = 1;

    private Segment.Builder buffer = new Segment.Builder();

    private boolean textContinue = false;
    private int textStartLine = -1;
    private int textStartColumn = -1;
    private long textStartOffset = -1;

    Segment build() {
        return buffer.build();
    }

    private int skip() {
        // track whitespaces only if the current segment is in active (chops the leading spaces)
        if (buffer.isInitialized()) {
            flushUnhandled();
            appendText();
        }
        return SAW_BODY;
    }

    private int token(TokenKind kind) {
        initialize();
        flushUnhandled();
        appendText();
        buffer.addToken(new TokenInfo(kind, buffer.relative(yychar), yylength(), yyline, yycolumn));
        if (kind.isStatementDelimiter()) {
            return SAW_DELIMITER;
        }
        return SAW_BODY;
    }

    private int unhandled() {
        initialize();
        appendText();
        if (!textContinue) {
            textStartLine = yyline;
            textStartColumn = yycolumn;
            textStartOffset = yychar;
            textContinue = true;
        }
        return SAW_BODY;
    }

    private int eof() {
        initialize();
        flushUnhandled();
        buffer.addToken(new TokenInfo(TokenKind.EOF, buffer.relative(yychar), 0, yyline, yycolumn));
        return SAW_EOF;
    }
    
    private void initialize() {
        if (!buffer.isInitialized()) {
            buffer.initialize(yychar);
        }
    }
    
    private void appendText() {
        buffer.append(yytext());
    }

    private boolean flushUnhandled() {
        // TODO: continue unhandled text until statement delimiter was occurred
        if (textContinue) {
            long textEndOffset = yychar;
            buffer.addToken(new TokenInfo(
                    TokenKind.UNHANDLED_TEXT,
                    buffer.relative(textStartOffset),
                    (int) (textEndOffset - textStartOffset),
                    textStartLine,
                    textStartColumn));
            textStartLine = -1;
            textStartColumn = -1;
            textStartOffset = -1;
            textContinue = false;
        }
        return true;
    }
%}

LETTER = [A-Za-z_]

DIGIT = [0-9]

WHITE_SPACES  = [ \t\r\n]+

HYPHEN_COMMENT = "--" [^\r\n]*

SLASH_COMMENT = "//"  [^\r\n]*

BLOCK_COMMENT = "/*" ~ "*/"


REGULAR_IDENTIFIER = {LETTER} ( {LETTER} | {DIGIT} )*

DELIMITED_IDENTIFIER = "\"" ( "\\" . | [^\\\"] )* "\""

NUMERIC_LITERAL = ( {DIGIT}+ ( "." {DIGIT}* )? | "." {DIGIT}+ ) ( "E" [+\-]? {DIGIT}+ )?

BOOLEAN_LITERAL = ( "TRUE" | "FALSE" )

NULL_LITERAL = "NULL"

CHARACTER_STRING_LITERAL = "'" ( "\\" . | [^\\'] )* "'"

BINARY_STRING_LITERAL = "X" {CHARACTER_STRING_LITERAL}

SPECIAL_COMMAND = "\\" {LETTER} ( {LETTER} | {DIGIT} )*

// punctuations or operators
DOT = "."
COMMA = ","
SEMICOLON = ";"
LEFT_PAREN = "("
RIGHT_PAREN = ")"
PLUS = "+"
MINUS = "-"
ASTERISK = "*"

TEXT = .

%%

{WHITE_SPACES}              { return skip(); }

// comments
{HYPHEN_COMMENT}            { return token(TokenKind.HYPHEN_COMMENT); }
{SLASH_COMMENT}             { return token(TokenKind.SLASH_COMMENT); }
{BLOCK_COMMENT}             { return token(TokenKind.BLOCK_COMMENT); }

// values
{BOOLEAN_LITERAL}           { return token(TokenKind.BOOLEAN_LITERAL); }
{NULL_LITERAL}              { return token(TokenKind.NULL_LITERAL); }
{REGULAR_IDENTIFIER}        { return token(TokenKind.REGULAR_IDENTIFIER); }
{DELIMITED_IDENTIFIER}      { return token(TokenKind.DELIMITED_IDENTIFIER); }
{NUMERIC_LITERAL}           { return token(TokenKind.NUMERIC_LITERAL); }
{CHARACTER_STRING_LITERAL}  { return token(TokenKind.CHARACTER_STRING_LITERAL); }
{BINARY_STRING_LITERAL}     { return token(TokenKind.BINARY_STRING_LITERAL); }
{SPECIAL_COMMAND}           { return token(TokenKind.SPECIAL_COMMAND); }

// punctuations or operators
{DOT}                       { return token(TokenKind.DOT); }
{COMMA}                     { return token(TokenKind.COMMA); }
{SEMICOLON}                 { return token(TokenKind.SEMICOLON); }
{LEFT_PAREN}                { return token(TokenKind.LEFT_PAREN); }
{RIGHT_PAREN}               { return token(TokenKind.RIGHT_PAREN); }
{PLUS}                      { return token(TokenKind.PLUS); }
{MINUS}                     { return token(TokenKind.MINUS); }
{ASTERISK}                  { return token(TokenKind.ASTERISK); }

// unhandled text
{TEXT}                      { return unhandled(); }